{"version":3,"sources":["App.tsx","reportWebVitals.ts","index.tsx"],"names":["startPatterns","isVowel","letter","length","includes","isConsonant","App","useState","priceLimit","setPriceLimit","newPattern","setNewPattern","patterns","setPatterns","showPatternsExplanation","setShowPatternsExplanation","domains","setDomains","useEffect","a","fetch","resp","json","filtered","filter","domain","name","price","filterPatterns","Object","entries","key","push","some","pattern","str","replace","i","pat","test","Number","patternMatch","priceArr","split","result","join","priceToNumber","className","value","onChange","e","isNaN","target","onClick","map","type","checked","window","WebSocket","undefined","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.066933de.chunk.js","sourcesContent":["import React, { useEffect, useState } from 'react';\nimport './App.scss';\nconst PRICE_LIMIT = 10000\nconst VOWEL_SYMBOL = '_'\nconst CONSONANT_SYMBOL = '$'\nconst startPatterns = {\n  '_$_$': false,\n  '$_$_': true,\n  '$__$': false,\n  '$_0_': false,\n  '$_$2_': false,\n  '$_$$_': false,\n  '$_11$': false,\n}\n\nconst patternMatch = (str: string, pattern: string) => {\n  if (str.replace('.com', '').length !== pattern.length) {\n    return false\n  }\n  for (let i = 0; i < pattern.length; i++) {\n    const letter = str[i]\n    const pat = pattern[i]\n    if (pat === '*') {\n      continue\n    }\n    if (pat === CONSONANT_SYMBOL) {\n      if (!isConsonant(letter)) {\n        return false\n      }\n    } else if (pat === VOWEL_SYMBOL) {\n      if (!isVowel(letter)) {\n        return false\n      }\n    } else if (/[0-9]/.test(pat)) {\n      if (letter !== str[Number(pat)]) {\n        return false\n      }\n    } else if (letter !== pat) {\n      return false\n    }\n  }\n  return true\n}\nconst isVowel = (letter:string) => (\n  letter.length === 1 && ['a','e','i','o','u','y'].includes(letter)\n)\nconst isConsonant = (letter:string) => !isVowel(letter)\nconst priceToNumber = (price:string) => {\n  const priceArr = price.split('')\n  const result = []\n  for (const letter of priceArr) {\n    if (/[0-9]/.test(letter)) {\n      result.push(letter)\n    }\n  }\n  return Number(result.join(''))\n}\nfunction App() {\n  const [priceLimit, setPriceLimit] = useState(10000)\n  const [newPattern, setNewPattern] = useState(\"\")\n  const [patterns, setPatterns] = useState(startPatterns)\n  const [showPatternsExplanation, setShowPatternsExplanation] = useState(false)\n  const [domains, setDomains] = useState<{\n    name: string\n    price: string\n  }[]>([])\n  useEffect(() => {\n    ;(async() => {\n      const resp = await fetch('domains.json')\n      const domains = await resp.json()\n      setDomains(domains)\n    })()\n  }, [])\n  const filtered = domains.filter(domain => {\n    const { name, price } = domain\n    const filterPatterns: string[] = []\n    for (const [key, value] of Object.entries(patterns)) {\n      if (value) {\n        filterPatterns.push(key)\n      }\n    }\n    return filterPatterns.some(pattern => patternMatch(name, pattern))\n      && priceToNumber(price) < Number(priceLimit)\n  })\n  return (\n    <div className=\"App\">\n      <label className=\"price-limit\">\n        price limit: <input\n          value={priceLimit}\n          onChange={(e:any) => {\n            if(!Number.isNaN(Number(e.target.value)))\n              setPriceLimit(e.target.value)\n          }}\n          />\n      </label>\n      <label className=\"new-pattern\">\n        new pattern: <input\n          value={newPattern}\n          onChange={(e:any) => {\n              setNewPattern(e.target.value)\n          }}\n          />\n      </label>\n      <button className=\"add-new-pattern\" onClick={() => {\n        setPatterns({\n          ...patterns,\n          [newPattern]: true\n        })\n        setNewPattern(\"\")\n      }}>\n        Add Pattern\n      </button>\n      <button\n        className=\"explanation\"\n        onClick={() => {\n          setShowPatternsExplanation(!showPatternsExplanation)\n        }}>\n        How Patterns Work\n      </button>\n      {!showPatternsExplanation ? \"\" : (\n        <div>\n          <p>\n            A '$' represents a consonant.\n          </p>\n          <p>\n            A '_' represents a vowel.\n          </p>\n          <p>\n            Any letter represents itself.\n          </p>\n          <p>\n            A number represents the 0-indexed character in the string. So, for a domain that's all the same letter, I would make the pattern '$000', that's consonant, then the same consonant, then the same consonant, then the same consonant, e.g. cccc.\n          </p>\n          <p>\n            A '*' can represent any character.\n          </p>\n        </div>\n      )}\n      <div className=\"patterns\">\n        {Object.entries(patterns).map(([key, value]) => {\n          return (\n            <label onClick={() => {\n              setPatterns({\n                ...patterns,\n                [key]: !value\n              })\n            }}>\n              <input type=\"checkbox\" checked={value} />\n              {key}\n            </label>\n          )\n        })}\n      </div>\n      <table>\n        <tbody>\n        {filtered.map(domain => {\n          return (\n            <tr>\n              <td>{domain.name}</td>\n              <td>{domain.price}</td>\n            </tr>\n          )\n        })}\n        </tbody>\n      </table>\n    </div>\n  );\n}\n\nexport default App;\n\n(window as any).WebSocket = undefined","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}